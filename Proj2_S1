clc;
clear;
%%Initialization
%%% PROJECT 2 PARAMETERS %%% 
% The following parameters are to be used for Project 2, and some will be
% used for Project 3 which will be commented out at the bottom of the
% script. 

% Vehicle Parameters
carData.Inertia = 1600; % kg m^2  -  Car Inertia
carData.Mass = 1500; % kg      -  Car Mass 


% Initial Conditions
carData.init.X0 = 0;        % m - Initial X Position of the Car
carData.init.Y0 = 0;        % m - Initial Y Position of the Car
carData.init.vx0 = 0.1;     % m/s - Initial Velocity in X of the Car
carData.init.vy0 = 0;       % m/s - Initial Velocity in Y of the Car
carData.init.omega0 = 0;    % rad/s - Initial Yaw Rate of the Car
carData.init.psi0 = 0;      % rad - Initial Heading of the Car


% Vehicle Tire Information 
carData.Calpha_f = 400; % N/rad - Front Tire Coefficient (slope)
carData.Calpha_r = 400; % N/rad - Rear Tire Coefficient (slope)
carData.Fyfmax = 400*1/180*pi; % N - Max Front Tire Force
carData.Fyrmax = 400*1/180*pi; % N - Max Rear Tire Force
carData.lr = 1.5; % m - Distance from CG to rear axis
carData.lf = 1.0; % m - Distance from CG to front axis
carData.radius = 0.4; % m - Radius of tires


track_radius = 200;
carData.understeerCoeff = ... % Understeering Coefficient 
    carData.Mass / ((carData.lr + carData.lf) * track_radius) ...
      * (carData.lr / carData.Calpha_f - ...
         carData.lf / carData.Calpha_r);


carData.maxAlpha = 1 / 180 * pi; % Max Alpha Angle for Tires


carData.vxd = 12.; % m/s - Desired Velocity in X
carData.vx_threshold1 = 0.1; % m/s - Threshold for Velocity in X
carDataBus = Simulink.Bus.createObject(carData);

%% Gentrack
path.pure_pursuit_lookaheaddist = 10; % m - look ahead distance

path.radius = 200; % assigning the radius of the track into a structure called "path"
path.l_st = 900; % assigning the straight length of the track into a structure called "path"

path.width = 15; % assigning the width of the track into a structure called "track"

radius = path.radius; % assigning radius from struct
    
l_st = path.l_st; % assigning straightaway from struct

l_curve = pi * radius; % assigning the length of curve (circumference divided by two since its only half)

path.total_length = 2 * l_st + 2 * l_curve; % the total length of the track

delta_s = 10;
npts = round(path.total_length/delta_s); % number of data points

delta_s = path.total_length/(npts-1); % the step size for the total length of track for 1 - number of points
 
delta_theta = delta_s / radius; % the step size for the curve portions

path.xpath = zeros(npts,1); % an array of zeros for the x component center path
path.ypath = zeros(npts,1); % an array of zeros for the y component center path
path.tpath = zeros(npts,1); % an array of zeros for the theta component of the overall path
path.xinpath = zeros(npts,1); % an array of zeros for the x component inside path
path.yinpath = zeros(npts,1); % an array of zeros for the y component inside path
path.xoutpath = zeros(npts,1); % an array of zeros for the x component outside path
path.youtpath = zeros(npts,1); % an array of zeros for the y component outside path



i = 1; % counter for what data point we're at

while i < npts % while the counter is less than the number of points
path.yinpath(1) = 7.5; % initializing where inside border starts 
path.youtpath(1) = -7.5; % initializing where outside border starts

    if path.xpath(i) < l_st % if the x component at the index of the counter is less than the straightaway length

        if path.xpath(i) >= 0 % if that x component is more than or equal to zero

            if path.ypath(i) < radius % if the y component at the counter index is less than the radius length

                % at this condition, we are at the start point of the
                % track, so the first x and y will be at 0, y will continue
                % to be 0 since we are at the first straightaway section

                path.xpath(i+1) = path.xpath(i) + delta_s; % at the next index, the x component is the previous plus the step size 
                path.ypath(i+1) = path.ypath(i); % since the y component has not reached the curve yet, it will stay the same point at the straight away

                path.xinpath(i+1) = path.xinpath(i) + delta_s; 
                path.yinpath(i+1) = path.yinpath(i);

                path.xoutpath(i+1) = path.xoutpath(i) + delta_s;
                path.youtpath(i+1) = path.youtpath(i);

                path.tpath(i+1) = 0; % straightaway is at theta of 0, think of it like a unit circle
            else

                % this is for the second straightaway section
                path.xpath(i+1) = path.xpath(i) - delta_s; % since second straightaway is going in the negative x direction, subtract by delta_s
                path.ypath(i+1) = path.ypath(i); % y component will stay the same a the second straightaway (400 meters in y axis)

                path.xinpath(i+1) = path.xinpath(i) - delta_s; 
                path.yinpath(i+1) = path.yinpath(i);

                path.xoutpath(i+1) = path.xoutpath(i) - delta_s; 
                path.youtpath(i+1) = path.youtpath(i);
                path.tpath(i+1) = pi; % second straightaway is at theta of pi, remember unit circle
            end
        else

            % for the second curved section
            cx = 0; cy = radius;
            rx = path.xpath(i) - cx; ry = path.ypath(i) - cy;
            rxin = path.xinpath(i) - cx; ryin = path.yinpath(i) - cy;
            rxout = path.xoutpath(i) - cx; ryout = path.youtpath(i) - cy;

            tt = rotate([rx;ry], delta_theta); 
            ttin = rotate([rxin;ryin], delta_theta); 
            ttout = rotate([rxout;ryout], delta_theta); 

            path.xpath(i+1) = tt(1) + cx; 
            path.ypath(i+1) = tt(2) + cy;

            path.xinpath(i+1) =  ttin(1) + cx; 
            path.yinpath(i+1) = ttin(2) + cy;

            path.xoutpath(i+1) = ttout(1) + cx; 
            path.youtpath(i+1) = ttout(2) + cy;
            path.tpath(i+1) = path.tpath(i) + delta_theta;
        end
    else

        % once the x component of the path is larger than the length of the
        % straightaway, it has reached the first curved portion of the track

        cx = l_st; cy = radius;                 % assigning the length of straightaway and the radius as x and y components respectively
        rx = path.xpath(i) - cx; ry = path.ypath(i) - cy; % subtracting the x and y path components by their original lengths
        rxin = path.xinpath(i) - cx; ryin = path.yinpath(i) - cy;
        rxout = path.xoutpath(i) - cx; ryout = path.youtpath(i) - cy;

        tt = rotate([rx;ry],delta_theta);    % rotating the rx and ry components by delta theta using p2_rotate function
        ttin = rotate([rxin;ryin], delta_theta); 
        ttout = rotate([rxout;ryout], delta_theta);

        path.xpath(i+1) = tt(1) + cx;                % adding the transformed x component to the original length of straightaway
        path.ypath(i+1) = tt(2) + cy;                % adding the transformed y component to the original radius 

        path.xinpath(i+1) =  ttin(1) + cx; 
        path.yinpath(i+1) = ttin(2) + cy;

        path.xoutpath(i+1) = ttout(1) + cx;
        path.youtpath(i+1) = ttout(2) + cy;
        path.tpath(i+1) = path.tpath(i) + delta_theta; 
    end
    i = i + 1;    
end
function v_rot = rotate(v, theta)
    % Rotate 2D vector v by angle theta (radians)
    R = [cos(theta), -sin(theta);
         sin(theta),  cos(theta)];
    v_rot = R * v;
end

%% Animate
% From a Kinematic Model
simout = sim("Project_2_Kinematic_Model.slx");
car_X = simout.X.Data;
car_Y = simout.Y.Data;
car_psi = simout.psi.Data;
car_time = simout.tout;

path_X = path.xpath;
path_Y = path.ypath;
% Animating the patch
fh = figure();
fh.WindowState = 'maximized';
hold on
plot(path.xpath,path.ypath,'--r'); axis equal; % plots center line
plot(path.xinpath, path.yinpath, 'b'); axis equal; % plots inside border 
plot(path.xoutpath, path.youtpath,'b'); axis equal; % plots outside border
axis([min(path.xoutpath)-100 , max(path.xoutpath)+100 , min(path.youtpath)-100 , max(path.youtpath)+100]) % limits axis for better viewing
xlabel('X Distance (m)') % x axis label
ylabel('Y Distance (m)') % y axis label
title('Project 2 Track') % title
grid
h = animatedline; % handle of animatedline

L = 5;
width = 1.7;
for i = 1:length(car_X)
    x = car_X(i);
    y = car_Y(i);
    psi = car_psi(i); % heading angle (radians)

    % Car vertices (centered at origin)
    car = [-L/2 -width/2;
           -L/2  width/2;
            L/2  width/2;
            L/2 -width/2];

    % Rotation matrix
    R = [cos(psi) -sin(psi);
         sin(psi)  cos(psi)];

    % Rotate and translate
    rcar = (R * car')';
    rcar = rcar + [x, y];

    % Plot
  %  addpoints(h,x,y);
    a = polyshape(rcar);
    ap = plot(a, 'FaceColor', 'k');
    drawnow limitrate;
    pause(0.05);
    delete(ap);
    
end
race = raceStat(car_X, car_Y, car_time, path);
%hold off;
